打包:处理JS语言中比较割裂的模块化的生态

在ES6之前没有模块化的规范 

## CommonJS  
nodeJS的模块化规范  不能直接用在浏览器中  
require()   module.exports=  导入导出  

核心原理:
全局放置了一个require函数,基于require函数路径找到对应模块文件的绝对路径,基于绝对路径将文件读取出来-->通过fs对应的方法从硬盘上读取出文件的内容.读取出的内容是字符串形式,把它变为可执行的js代码段让其能执行起来
为保证每个模块作用域的唯一会在每个字符串外层包裹一个字符串函数,再通过nodejs原生的vm(virtual machine虚拟机)来运行

完全由环境来实现的模块化规范,做了哪些解析/封装/再处理?

同步的规范  代码运行到require函数之后才会读取文件路径所在的内容  通过读取出来的文件结果,对模块内容进行处理,再通过对应的语法进行导入导出,最终把require结果的返回值作为模块的导出值,赋值给当前文件的变量  

浏览器中这样分割模块存在的问题:  
每当遇到一个模块时去同步加载会很容易造成阻塞



## AMD
浏览器的模块化规范    不能使用在nodeJS中

异步规范  使得在js的家在过程中不会阻塞其他文件(比如:UI/点击事件)的渲染 

## ESModule

CommonJS AMD 是语言上层环境实现的模块化规范, 受限于环境本身的特性才这样进行规范的.相互之间协同性不好
需要通过打包工具把一个普通模块在不同环境之间进行切换,基于打包工具对模块进行处理

import export 关键词进行导入导出

当前js运行环境的解析器满足解析环境才能直接去使用,否则执行到当前行的时候无法认识关键词,导致语法错误报错.
当前的解析环境需要知道关键词的用法,因而需要先进行编译处理,将其变为能在低版本环境上运行的代码

nodeJS(global  process)   浏览器(document window)   小程序(wx swan)



babel编译会将import export关键字编译为 require  module.exports的CommonJS规范--->不能在浏览器直接执行,因此在编译完成后还要进行打包的处理(打包的目的:保证CommonJS模块在各个平台都能运行,实际上就是将模块化内部细节进行抹平)



经过编译&&打包后的代码是能够在各个平台运行的代码-->因而一定是纯JS的代码/实现模块的转化/把模块化的部分进行处理掉
