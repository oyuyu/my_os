# 工程化

## 简介
项目的开发到上线的处理过程(复杂系统的通用解决方案) 即工程化思维

用工具处理与实际业务无关的内容,比如:

1. 系统复杂度提升 多js文件打包的结果
2. js的编译/打包/压缩
3. 高版本的js语法如何处理的更加通用, 使打包结果运用到不同平台
4. 上线后压缩js代码
5. 图片的合并以及优化
等...

|分类 |工具|
|- |-|
| 包管理工具 | npm yarn 
| 静态检查&&格式化工具| eslint prettier
| 编译工具| babel
| 打包工具| rollup broserify
| 压缩工具| uglify
| 任务处理|
| 通用处理工具| webpack

## 包管理工具

通用模块的处理发布在一个平台上, 其他人下载这部分通用代码,达到逻辑的复用 ->模块化思维
这种通用的模块化代码,成为包(package)

公司内部的包是怎么管理的?
公司内部配置一个私有的包管理平台, 通过对应的命令进行安装.比如改变npm的部分内容,加一些鉴权等 就可以自己搞出一些新的命令 走公司内部私有的源

### npm 
npm: node package manage. 我们可以通过npm publish 发布包/ npm i 下载别人发布的包

npm包要有package.json文件
```
{
    "name": "包/模块/项目名",
    "version": "版本号",
    "main": "默认加载的入口文件",
    "private": true,
    <!-- 运行时需要的模块 -->
    "dependencies": {
        "@babel/cli": "^7.17.6",
        "@babel/core": "^7.17.8",
        "@babel/plugin-proposal-class-properties": "^7.16.7",
        "@babel/plugin-proposal-decorators": "^7.17.8",
        "@babel/polyfill": "^7.12.1",
        "@babel/preset-env": "^7.16.11",
        "install": "^0.13.0",
        "npm": "^8.5.5"
    },
    <!-- 本地开发需要的依赖,运行时并不需要 -->
    "devDependencies": {
        eslint:'^6.6.1'
    }
    <!-- 必要依赖的版本,但是并不需要显式的去下载 -->
    "peerDependencies": {
        比如一个包 webpack-plugin-x单独作为一个Npm包发布, 使用的时候一定要有webpack, 因为如果不使用webpack的话也不会使用这个插件, 也就是说webpack-plugin-x是依赖于webpack的,但是不会显示让用户去下载webpack,而是把webpack的控制权交给使用者

        !!!如果本身安装的版本与包依赖的版本不匹配  就有警告
    }
    <!-- 脚本 -->
    "scripts": {
        "babel": "npm run ./node_modules/.bin/babel async.js --out-dir=./dist"
    }
}
```
|图标|版本锁定|
|-|-|
|~| 安装 1.3.X的最新版本|
|^| 安装 1.X.X的最新版本|
||

npm i xxx --save-dev   devDependencies  
npm i xxx --save  dependencies  
npm --production i 只会安装save安装的包 
---
### yarn

---
### nrm
镜像源管理工具

nrm ls  查看所有的源  
nrm add [name] http://xxxx  添加源地址  
nrm use [name] 使用源地址  
nrm del [name] 删除源地址

---
## 静态检查&&格式化工具
Eslint   pretieer

## 范JS的编译
babel : 在静态阶段处理代码和编译
|||
|-|-|
|@babel/cli(command line tool)|babel命令行工具内部解析相关方法|
|@babel/core|babel内部核心的编译和生成代码的方法|
|@babel/preset-env|关于环境的预设,对于环境babel编译的结果|
|@babel/polyfill|新语法的补丁|
 
 
安装@babel/cli @babel/core这两个包后可以使用babel相关方法对代码进行操作,然后进行配置告诉babel需要将代码变成什么
  


.babelrc
```js
{
  //环境预设
  presets: ['@babel/preset-env'],   
}
```

**命令**  
|命令| |
|-|-|
|babel 文件名 -o 输出文件名| -o 输出|
|||


## 打包工具   devdependence
针对不同的模块快规范进行处理,把各种不同模块化规范的不同之处进行抹平,实现通用的模块化规范文件
### JS规范
#### CommonJS
 不经处理只能运行在nodeJS环境
 是一个运行时的规范,  因为require('')是一种方法,只有到执行到这个方法的时候才知道依赖哪个模块

#### AMD 
不经处理 无法运行在各个平台.需要搭配require.js一起使用
#### ESModule
从语言层解决了规范问题, 经编译之后将import export关键词转化为CommonJS的 require exports, 无法在浏览器直接使用

browserify   
将CommonJS代码转为通用的任何环境可以加载的模块化规范

rollup   
提出了tree shaking的概念,可以在静态分析阶段移除代码中的无用的代码,会对未使用的导出内容进行标记,在压缩过程中将这类代码移除

限制:
1. 无副作用  import进来了  但是没被使用
2. 需要使用ESModule的规范进行导入  ESModule是一个静态的规范,能够在静态阶段对依赖进行分析.  而CommonJS是运行时的规范,因此不能在静态阶段分析出里面的内容

## 压缩工具
uglify

# 通用处理工具
webpack 更像是一种解决方案.是一种平台化的内容  
不是某个垂直领域单独左某一件事的工具,而是将整个流程串起来:格式检查/编译/打包/压缩

内部会做一些处理,比如:图片合并/文件打包编译 成hash文件等/


NodeJS执行的过程
fs读取文件
包裹为一个函数 function(){}()
基于VM执行字符串
基于对象引用获取导出值












loader plugin什么区别? 分别用于什么场景

loader 面向切面的过程   面向某一类文件


plugin 面向整体的一些东西




import可以加载本地文件能加载第三方资源吗?
webpack5  可加载远程动态资源 




自动构建部署持续相关的概念与实现
CI/CD  平台的配置-对服务器的集群  对代码进行不同的处理
怎么实现/配置  

一般基于gitserver  与gitlab进行配合在项目里进行动态拉取,执行对应的脚本
